name: Branch Protection

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

jobs:
  enforce:
    name: Enforce Branch Protection
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      checks: write
      statuses: write

    steps:
      - name: Block force pushes
        if: github.event_name == 'push' && github.event.forced == true
        uses: actions/github-script@v6
        with:
          script: |
            core.setFailed('Force pushes are not allowed on protected branches');

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Verify branch is up to date
      - name: Check branch status
        if: github.event_name == 'pull_request'
        run: |
          git fetch origin main
          COMMITS_BEHIND=$(git rev-list --count HEAD..origin/main)
          if [ $COMMITS_BEHIND -gt 0 ]; then
            echo "❌ Branch is $COMMITS_BEHIND commits behind main"
            exit 1
          fi

      # Check required status checks
      - name: Verify status checks
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const requiredChecks = [
              'test',
              'security-scan',
              'codeql',
              'pr-review'
            ];
            
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.pull_request.head.sha
            });
            
            const missingChecks = requiredChecks.filter(required => 
              !checks.check_runs.some(check => 
                check.name.includes(required) && check.conclusion === 'success'
              )
            );
            
            if (missingChecks.length > 0) {
              core.setFailed(
                `Missing required status checks: ${missingChecks.join(', ')}`
              );
            }

      # Verify commit signing
      - name: Check commit signatures
        run: |
          git log --since="1 week ago" --format="%H %GK" | while read -r commit key; do
            if [ "$key" = "" ]; then
              echo "❌ Unsigned commit found: $commit"
              exit 1
            fi
          done

      # Check linear history
      - name: Verify linear history
        if: github.event_name == 'pull_request'
        run: |
          MERGE_BASE=$(git merge-base HEAD origin/main)
          COMMITS=$(git rev-list --count $MERGE_BASE..HEAD)
          if [ $COMMITS -gt $(git rev-list --count HEAD ^$MERGE_BASE) ]; then
            echo "❌ Non-linear history detected"
            exit 1
          fi

      # Enforce issue links
      - name: Check issue references
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const body = context.payload.pull_request.body || '';
            const issuePattern = /(close[sd]?|fix(es|ed)?|resolve[sd]?)\s*:?\s*#\d+/i;
            
            if (!issuePattern.test(body)) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: '❌ PR description must reference an issue using keywords (fixes #X, closes #Y, etc)'
              });
              core.setFailed('Missing issue reference in PR description');
            }

      # Check protected files
      - name: Protected files check
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const protectedFiles = [
              '.github/workflows/**',
              'src/lib/stripe/config.ts',
              'supabase/migrations/**'
            ];
            
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            const protectedChanges = files.filter(file => 
              protectedFiles.some(pattern => 
                new RegExp(pattern.replace('*', '.*')).test(file.filename)
              )
            );
            
            if (protectedChanges.length > 0) {
              const fileList = protectedChanges
                .map(f => `- ${f.filename}`)
                .join('\n');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `⚠️ Changes to protected files require admin review:\n${fileList}`
              });
              
              // Add review request for admin team
              await github.rest.pulls.requestReviewers({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                team_reviewers: ['admins']
              });
            }

      # Report status
      - name: Update branch status
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const conclusion = '${{ job.status }}' === 'success' ? 
              'Branch protection rules satisfied' : 
              'Branch protection rules not met';
            
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Branch Protection',
              head_sha: context.sha,
              status: 'completed',
              conclusion: '${{ job.status }}' === 'success' ? 'success' : 'failure',
              output: {
                title: conclusion,
                summary: 'Branch protection workflow completed'
              }
            });